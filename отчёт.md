Основная задача - расшифровка шифров подстановки. О методе можно почитать [тут](http://utstat.toronto.edu/WSFiles/technicalreports/1005.pdf)

Файлы прикладываю. За что отвечает каждый:

#### utils.py

Вспомогательные функции. Понимаем, является ли символ русской или английской буквой, чистим текст от пунктуации, зашифровываем текст.

#### training_models.py

Чтобы алгоритм работал, он должен знать, насколько часто встречается в языке каждая пара последовательных букв. `train_m(corpus, language='ru')` по данному имени файла с большим текстом и языку выдаёт `alphabet` - буквы в порядке от более частым к менее частым и словарь `m`, который по паре букв (строке длины 2) говорит, сколько раз эти две буквы встречались подряд в тексте. 

Если запустить training_models.py, то программа сделает это для русского и английского текстов из папки `corpuses` и сохранит результат в папку `models`.

#### mcmc_decryptor.py

Файл с основным классом `MetropolisDecryptor`. Конструктор принимает `alphabet` и `m`. Умеет кушать текст (метод start_from), очищенный от пунктуации, и инициализировать все параметры. Изначально символы текста ставятся в соответствие (`map`) буквам так, чтобы более частые символы в тексте соответствовали более частым буквам языка.

Каждая попытка расшифровать текст получает score: перемножаем значения m[ch1 + ch2] по всем соседним символам ch1 и ch2 в расшифрованном тексте. (например, 'to the did' получит высокий score, а 'qw qhj xkx' - низкий, потому что такие сочетания букв редки). Метод compute_score вычисляет score текста, расшифрованного данной map. Вспомогательный метод decrypt расшифровывает текст с помощью данной map.

Метод metropolis_step делает шаг алгоритма. Случайно выбираются два символа, и соответствующий им буквы меняются местами. Вычисляется score текста, расшифрованного новым соответствием символ-буква. Если он больше старого, то замена принимается. Если меньше, то принимается с вероятностью (новый score) / (старый score). (на scaling_factor не обращайте внимания, он не пригодился) (опция broken=True заставила бы нас принимать замену только если она увеличивает score. Оказывается, с broken=True на коротких сообщениях работает хуже, так что наворот с принятием замены, уменьшающей score, полезен)

Метод run просто делает много шагов. Может выводить информацию в процессе. Если максимальный score не менялся early_stop итераций, то процесс обрывается.

Метод final переводит текст с помощью map, дающей максимальный score (она в процессе запоминается в best_map)

Метод plot рисует, как в процессе менялся score.

Метод acc_rate выдает, сколько процентов предложенных замен алгоритм принял.

#### testing.py

Тут я тестировал этот класс. Сообщения для тестирования положил в папку test_messages.

#### app.py

Основной файл с приложением. Здесь уже ничего хитрого не происходит. 

Статика лежит в папке static.

Шаблоны - в templates. Есть базовый base.html и наследуемые от него main.html и about.html.

Примеры работы с сайтом смотрите в папке "пример работы".

Для тестирования производительности создана дополнительная страница /test, которая запускает расшифровку фиксированного текста на русском.

#### gunicorn и ab

Запуск gunicorn:

```
(base) kirill@kirill-laptop:~/PycharmProjects/MCMC_web$ gunicorn -w 4 -b 0:8000 app:app
[2020-04-16 12:21:20 +0300] [32288] [INFO] Starting gunicorn 20.0.4
[2020-04-16 12:21:20 +0300] [32288] [INFO] Listening at: http://0.0.0.0:8000 (32288)
[2020-04-16 12:21:20 +0300] [32288] [INFO] Using worker: sync
[2020-04-16 12:21:20 +0300] [32291] [INFO] Booting worker with pid: 32291
[2020-04-16 12:21:20 +0300] [32292] [INFO] Booting worker with pid: 32292
[2020-04-16 12:21:20 +0300] [32293] [INFO] Booting worker with pid: 32293
[2020-04-16 12:21:20 +0300] [32294] [INFO] Booting worker with pid: 32294
```

Тестирование с помощью ab:

```
(base) kirill@kirill-laptop:~$ ab -n 10 -c 2 http://0.0.0.0:8000/test
This is ApacheBench, Version 2.3 <$Revision: 1807734 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking 0.0.0.0 (be patient).....done


Server Software: gunicorn/20.0.4
Server Hostname: 0.0.0.0
Server Port: 8000

Document Path: /test
Document Length: 5503 bytes

Concurrency Level: 2
Time taken for tests: 23.335 seconds
Complete requests: 10
Failed requests: 0
Total transferred: 56650 bytes
HTML transferred: 55030 bytes
Requests per second: 0.43 [#/sec] (mean)
Time per request: 4667.005 [ms] (mean)
Time per request: 2333.503 [ms] (mean, across all concurrent requests)
Transfer rate: 2.37 [Kbytes/sec] received

Connection Times (ms)
              min mean[+/-sd] median max
Connect: 0 0 0.1 0 0
Processing: 2737 4163 1037.8 3979 5882
Waiting: 2737 4163 1037.8 3979 5882
Total: 2737 4163 1037.7 3979 5882

Percentage of the requests served within a certain time (ms)
  50% 3979
  66% 4503
  75% 4636
  80% 5726
  90% 5882
  95% 5882
  98% 5882
  99% 5882
 100% 5882 (longest request)
```

Алгоритм требует большого объёма вычислений. Тысячу итераций на тексте длины 1-2 тысяча алгоритм выполняет примерно за секунду, так что, конечно, получается всё очень медленно. В данном случае тестируется запуск на тексте длины 1223 и 5000 итерациях.

Чтобы такой сервис был жизнеспособным, наверное, надо оптимизировать код и переписать его на Си, и запускать на мощном сервере с хорошим распараллеливанием. Или принимать задания в очередь и отдавать их, когда сделаются, как на http://deepart.io/


Я также позапускал gunicorn на 9и рабочих и ab с 1, 4 и 9 запросами за раз и увидел, как нагружаются 1, 4 и все 8 ядер (потоков?) процессора соответственно.

#### Общие впечатления

С вёрсткой разбирался довольно долго, потому что это всё в новинку. Читал документацию bootstrap, чтобы найти нужные элементы. Не сразу понял, как доставать вывод radiobutton (нужно было прописывать value). Долго не мог заставить panel делать переносы строки. В общем, были затруднения из-за отсутствия большого опыта с html и css. Написание алгоритма, приложения, установка gunicorn и ab тоже заняли время. В итоге довести работу до идеала не получилось, но надеюсь, я сделал достаточно.

Я постарался побольше разнести всё по классам и файлам, чтобы всё было аккуратно и не смешивалось.

Мне ещё понравилось сортировать символы symbols по убыванию их количеств в тексте s вот так:

```
cnt = Counter(s)
self.symbols.sort(key=cnt.get, reverse=True)
```

Красиво?